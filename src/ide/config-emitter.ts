/**
 * IDE Config Emitter — generates config files for IDE integration.
 *
 * Generates:
 * - eslint.config.mjs (project root) — required by VS Code ESLint extension
 * - .vscode/settings.json — Prettier formatter settings
 * - .vscode/extensions.json — recommends ESLint + Prettier extensions
 */
import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import type { QuickLintConfig } from '../types/index.js';
import { logger } from '../utils/logger.js';
import { buildPrettierConfig } from '../adapters/prettier.js';

/**
 * Generate IDE-readable config files.
 */
export async function emitIdeConfigs(config: QuickLintConfig): Promise<void> {
    if (!config.ide.generateConfigs) {
        logger.info('IDE config generation is disabled');
        return;
    }

    const cwd = process.cwd();

    await emitEslintConfig(cwd);
    await emitVscodeSettings(cwd, config);
    await emitVscodeExtensions(cwd);
    await updateGitignore(cwd);
}

/**
 * Generate eslint.config.mjs that re-exports from quicklint.
 * This is required for the VS Code ESLint extension to pick up settings
 * and provide real-time linting (ESLint + SonarJS) in the editor.
 *
 * The proxy is intentionally short — `quicklint` must be in node_modules
 * for the import to resolve. The `init` command ensures this.
 */
async function emitEslintConfig(cwd: string): Promise<void> {
    const filePath = path.join(cwd, 'eslint.config.mjs');

    const content = [
        '// Auto-generated by quicklint — DO NOT EDIT manually',
        '// This file enables real-time ESLint + SonarJS linting in your IDE.',
        '// Modify your quicklint.config.js and restart ide to update.',
        '',
        "import { loadConfig, buildEslintConfig } from 'quicklint-react';",
        '',
        'const config = await loadConfig();',
        'const eslintConfig = await buildEslintConfig(config);',
        '',
        'export default eslintConfig;',
        '',
    ].join('\n');

    await fs.writeFile(filePath, content, 'utf8');
    logger.success('Created eslint.config.mjs (IDE proxy)');
}

/**
 * Generate .vscode/settings.json with Prettier formatter settings.
 * Merges with existing settings if the file already exists.
 */
async function emitVscodeSettings(
    cwd: string,
    config: QuickLintConfig,
): Promise<void> {
    const vscodeDir = path.join(cwd, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });

    const filePath = path.join(vscodeDir, 'settings.json');
    const prettierConfig = buildPrettierConfig(config);

    // Read existing settings if any
    let existing: Record<string, unknown> = {};
    try {
        const raw = await fs.readFile(filePath, 'utf8');
        existing = JSON.parse(raw);
    } catch {
        // No existing settings
    }

    // quicklint managed settings
    const quicklintSettings: Record<string, unknown> = {
        // Enable ESLint flat config
        'eslint.useFlatConfig': true,

        // Prettier as default formatter
        'editor.defaultFormatter': 'esbenp.prettier-vscode',
        'editor.formatOnSave': true,

        // Prettier options from quicklint config
        'prettier.semi': prettierConfig.semi ?? true,
        'prettier.singleQuote': prettierConfig.singleQuote ?? true,
        'prettier.trailingComma': (prettierConfig.trailingComma as string) ?? 'all',
        'prettier.tabWidth': prettierConfig.tabWidth ?? 2,
        'prettier.printWidth': prettierConfig.printWidth ?? 100,
    };

    // Merge: existing settings take precedence (don't overwrite user customizations)
    const merged = { ...quicklintSettings, ...existing };

    await fs.writeFile(filePath, JSON.stringify(merged, null, 2) + '\n', 'utf8');
    logger.success('Created .vscode/settings.json (Prettier + ESLint settings)');
}

/**
 * Generate .vscode/extensions.json recommending ESLint and Prettier extensions.
 * Without these extensions, real-time IDE linting won't work.
 */
async function emitVscodeExtensions(cwd: string): Promise<void> {
    const vscodeDir = path.join(cwd, '.vscode');
    await fs.mkdir(vscodeDir, { recursive: true });

    const filePath = path.join(vscodeDir, 'extensions.json');

    // Read existing recommendations if any
    let existing: { recommendations?: string[] } = {};
    try {
        const raw = await fs.readFile(filePath, 'utf8');
        existing = JSON.parse(raw);
    } catch {
        // No existing file
    }

    const requiredExtensions = [
        'dbaeumer.vscode-eslint',       // ESLint — real-time linting + SonarJS
        'esbenp.prettier-vscode',       // Prettier — auto-formatting
    ];

    const currentRecs = existing.recommendations ?? [];
    const merged = [...new Set([...currentRecs, ...requiredExtensions])];

    const content = {
        ...existing,
        recommendations: merged,
    };

    await fs.writeFile(filePath, JSON.stringify(content, null, 2) + '\n', 'utf8');
    logger.success('Created .vscode/extensions.json (ESLint + Prettier recommendations)');
}

/**
 * Add a quicklint section to .gitignore (if not already present).
 */
async function updateGitignore(cwd: string): Promise<void> {
    const gitignorePath = path.join(cwd, '.gitignore');
    const marker = '# quicklint generated';

    let content = '';
    try {
        content = await fs.readFile(gitignorePath, 'utf8');
    } catch {
        // No .gitignore exists — we'll create one
    }

    if (content.includes(marker)) return;

    const addition = [
        '',
        marker,
        '# Uncomment below to gitignore the generated IDE config file.',
        '# It is safe to commit if you want consistent IDE behavior across the team.',
        '# eslint.config.mjs',
        '',
    ].join('\n');

    await fs.writeFile(gitignorePath, content + addition, 'utf8');
    logger.success('Updated .gitignore with quicklint section');
}

/**
 * Remove generated IDE config files.
 */
export async function removeIdeConfigs(): Promise<void> {
    const cwd = process.cwd();
    const files = [
        'eslint.config.mjs',
        // Legacy files from older versions
        '.prettierrc.json',
        'commitlint.config.cjs',
    ];

    for (const file of files) {
        try {
            await fs.unlink(path.join(cwd, file));
            logger.success(`Removed ${file}`);
        } catch {
            // File didn't exist — nothing to do
        }
    }
}

